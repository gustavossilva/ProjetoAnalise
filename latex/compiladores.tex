\documentclass[12pt,a4paper,twoside]{report}
% -------------------------------------------------------------------- %
% Pacotes

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[brazil]{babel}
\usepackage[fixlanguage]{babelbib}
\usepackage[pdftex]{graphicx}      % usamos arquivos pdf/png como figuras
\usepackage{setspace}              % espaçamento flexvel
\usepackage{indentfirst}           % indentação do primeiro parágrafo
\usepackage{makeidx}               % índice remissivo
\usepackage[nottoc]{tocbibind}     % acrescentamos a bibliografia/indice/conteudo no Table of Contents
\usepackage{courier}               % usa o Adobe Courier no lugar de Computer Modern Typewriter
\usepackage{type1cm}               % fontes realmente escaláveis
\usepackage{titletoc}
\usepackage{ucs}
\usepackage[font=small,format=plain,labelfont=bf,up,textfont=it,up]{caption}
\usepackage[usenames,svgnames,dvipsnames]{xcolor}
\usepackage[a4paper,top=2.54cm,bottom=2.0cm,left=2.0cm,right=2.54cm]{geometry} % margens
\usepackage{amsmath} 

\usepackage[pdftex,plainpages=false,pdfpagelabels,pagebackref,colorlinks=true,citecolor=DarkGreen,
linkcolor=NavyBlue,urlcolor=DarkRed,filecolor=green,bookmarksopen=true]{hyperref} % links coloridos
\usepackage[all]{hypcap}                % soluciona o problema com o hyperref e capítulos
\usepackage[square,sort,nonamebreak,comma]{natbib}  % citação bibliográfica alpha
\fontsize{60}{62}\usefont{OT1}{cmr}{m}{n}{\selectfont}
\usepackage{upquote}                    % formata apóstrofes '
\usepackage{textcomp}

% Para formatar corretamente as URLs
\usepackage{url}
% -------------------------------------------------------------------- %
% Cabeçalhos similares ao TAOCP de Donald E. Knuth
\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhf{}
\renewcommand{\chaptermark}[1]{\markboth{\MakeUppercase{#1}}{}}
\renewcommand{\sectionmark}[1]{\markright{\MakeUppercase{#1}}{}}
\renewcommand{\headrulewidth}{0pt}

% -------------------------------------------------------------------- %
\graphicspath{{./imagens/}}        % caminho das figuras
\frenchspacing                     % arruma o espaço: id est (i.e.) e exempli gratia (e.g.)
\urlstyle{same}                    % URL com o mesmo estilo do texto e no mono-spaced
\makeindex                         % para o índice remissivo
\raggedbottom                      % para no permitir espaços extras no texto
\fontsize{60}{62}\usefont{OT1}{cmr}{m}{n}{\selectfont}
\cleardoublepage
\normalsize

% -------------------------------------------------------------------- %
% Cores para formatação de código
\usepackage{color}
\definecolor{vermelho}{rgb}{0.6,0,0} % para strings
\definecolor{verde}{rgb}{0.25,0.5,0.35} % para comentários
\definecolor{roxo}{rgb}{0.5,0,0.35} % para palavras-chaves
\definecolor{azul}{rgb}{0.25,0.35,0.75} % para strings
\definecolor{cinza-claro}{gray}{0.95}
% -------------------------------------------------------------------- %
% Opções de listagem usados para o código fonte
% Ref: http://en.wikibooks.org/wiki/LaTeX/Packages/Listings



\usepackage{listings}           % para formatar código-fonte (ex. em Java)


\lstset{ %
language=[Objective]Caml,  % seleciona a linguagem do código (aqui em lstlang0.sty
basicstyle=\footnotesize\ttfamily, % o tamanho da fonte usado no código
commentstyle=\color{verde}\bfseries,  % formatação de comentários
stringstyle=\color{azul},    % formatação de strings
upquote=true,
numbers=left,                   % onde colocar os números de linha
numberstyle=\tiny,  % o tamanho da fonte usada para a numeração das linhas
stepnumber=1,                   % o intervalo entre dois números de linhas. Se for 1, numera cada uma.
numbersep=5pt,                  % how far the line-numbers are from the code
showspaces=false,               % show spaces adding particular underscores
showstringspaces=false,         % underline spaces within strings
showtabs=false,                 % show tabs within strings adding particular underscores
keywordstyle=\color{roxo}\bfseries,
keywordstyle=[1]\color{roxo}\bfseries,
keywordstyle=[2]\color{verde}\bfseries,
%        keywordstyle=[3]\textbf,    %
%        keywordstyle=[4]\textbf,   \sqrt{\sqrt{}} %
frame=b,                   % adds a frame around the code
framerule=0.6pt,
tabsize=2,                      % sets default tabsize to 2 spaces
captionpos=t,                   % sets the caption-position to top
breaklines=true,                % sets automatic line breaking
breakatwhitespace=false,        % sets if automatic breaks should only happen at whitespace
escapeinside={\%*}{*)},         % if you want to add a comment within your code
backgroundcolor=\color[rgb]{1.0,1.0,1.0}, % choose the background color.
rulecolor=\color[rgb]{0.8,0.8,0.8},
extendedchars=true,
xleftmargin=10pt,
xrightmargin=10pt,
framexleftmargin=10pt,
framexrightmargin=10pt,
literate={â}{{\^{a}}}1  % para formatar corretamente os acentos do Português ao usar utf8
    {ê}{{\^{e}}}1
    {ô}{{\^{o}}}1  
    {Â}{{\^{A}}}1
    {Ê}{{\^{E}}}1
    {Ô}{{\^{O}}}1
    {á}{{\'{a}}}1
    {é}{{\'{e}}}1
    {í}{{\'{i}}}1
    {ó}{{\'{o}}}1
    {ú}{{\'{u}}}1
    {Á}{{\'{A}}}1
    {É}{{\'{E}}}1
    {Í}{{\'{I}}}1
    {Ó}{{\'{O}}}1
    {Ú}{{\'{U}}}1
    {à}{{\`{a}}}1
    {À}{{\`{A}}}1
    {ã}{{\~{a}}}1
    {õ}{{\~{o}}}1
    {Ã}{{\~{A}}}1
    {Õ}{{\~{O}}}1
    {ç}{{\c{c}}}1
    {Ç}{{\c{C}}}1
    {ü}{{\"u}}1
    {Ü}{{\"U}}1
}

\renewcommand{\lstlistingname}{Listagem}
\renewcommand{\lstlistlistingname}{Lista de Listagens}

% Definição de novos estilos
\lstdefinestyle{Bash}
    {language=bash,frame=single,numbers=none,basicstyle=\footnotesize\ttfamily,
     morekeywords={cp,mkdir,sudo,tar}}

% Definição de novos ambientes
\lstnewenvironment{terminal}
  {\lstset{style=Bash}}
  {}

\lstnewenvironment{ocaml}
  {\lstset{basicstyle=\scriptsize\ttfamily,
           frame=single,
           frameround=tttt,
           framerule=2pt,
           numbers=none,
           rulecolor=\color{Salmon}}}
  {}

\lstnewenvironment{xml}
   {\lstset{language=XML,frame=single,numbers=none}}
   {}

\lstnewenvironment{interprete}
  {\lstset{frame=single,
            frameround=tttt,
            numbers=none,
            basicstyle=\ttfamily,
            framerule=2pt,
            rulecolor=\color{CadetBlue}}}
  {}
% Formata o caption da listagem
% \DeclareCaptionFont{blue}{\color{blue}} 

% \captionsetup[lstlisting]{singlelinecheck=false, labelfont={blue}, textfont={blue}}
\usepackage{caption}
\DeclareCaptionFont{white}{\color{white}}
\DeclareCaptionFormat{listing}{\colorbox[cmyk]{0.43, 0.35, 0.35,0.01}{\parbox{\textwidth}{\hspace{15pt}#1#2#3}}}
\captionsetup[lstlisting]{format=listing,labelfont=white,textfont=white, singlelinecheck=false, margin=0pt, font={bf,footnotesize}}

\newcommand{\ListingsPath}{./codigos}
% Inclui o nome do arquivo como Caption 
\newcommand{\filelisting}[2][]{%
    \lstinputlisting[caption={\texttt{\detokenize{#2}}},#1]{\ListingsPath/#2}%
}

% ---------------------------------------------------------------------------- %

% ---------------------------------------------------------------------------- %

\title{Análise de Algoritmos - Ordenação}
\date{}
\author{Gustavo de Souza Silva \\ Guilherme de Souza Silva \\ Arthur Xavier \\ Shumaiquer Souto \\
\vspace{1cm} \\
Faculdade de Computação \\
Universidade Federal de Uberlândia
}
\date{\today}

%\includeonly{cap-clojure,magical,short}
\begin{document}
  \maketitle
% -------------------------------------------------------------------- %
% Listas de figuras, tabelas e códigos criadas automaticamente
%\listoffigures            
%\listoftables            
\lstlistoflistings
% -------------------------------------------------------------------- %

% -------------------------------------------------------------------- %
% Sumário
\tableofcontents    

% Capítulos do trabalho

% cabeçalho para as páginas de todos os capítulos
\fancyhead[RE,LO]{\thesection}

%\singlespacing              % espaçamento simples
\setlength{\parskip}{0.15in} % espaçamento entre paragráfos

\chapter{Introdução}
Este documento foi escrito como relatório de uma tarefa com objetivo de aumentar minhas experiências de uso da linguagem fonte MiniC, possibilitar uma compreensão mais aprofundada dos códigos Assembly da plataforma LLVM (Low Level Virtual Machine) e desenvolver habilidade de uso das ferrramentas para a plataforma LLVM.

\section{LLVM}
Desenvolvida para otimizar em tempo de compilação, ligação(linker) e execução de programas escritos em várias linguagems de programação, LLVM (Low Level Virtual Machine) é uma infraescrutura de compilador escrita em C++. Inicialmente foi feita para C e C++, porém foi expandida para Java, Python, Ruby, Haskell e muitas outra linguagens.

\section{LLVM IR}
LLVM IR (LLVM Intermediate Representation) É o aspecto mais importante de um projeto, ele é a forma como é representado o código no compilador. Ele é o código intermediário do compilador, foi projetado para analisar e otimizar o código que foi compilado.

\section{Instalação}
Alguns pacotes devem ser instalados no linux Ubuntu para que seja feita a compilação e geração do código Assembly da LLVM.

\begin{terminal}
> sudo apt-get install llvm
> sudo apt-get install clang
\end{terminal}

Com o primeiro comando a llvm é instalada no sistema operacional, no segundo comando é instalada a interface clang, que faz o front-end do C para LLVM

Agora, podemos também instalar o OCAML, linguagem que será utilizada para fazermos o compilador, para isto digite:
\begin{terminal}
> sudo apt-get install ocaml
> sudo apt-get install rlwrap
\end{terminal}

O primeiro comando instala o ocaml no computador, já o segundo instala o rlwrap, que salva comandos executados no terminal e se faz muito útil neste documento.

\section{Compilando C em LLVM-IR e execuntado}
Para que seja feita a conversão de um código em linguagem C para LLVM-IR, deve ser feito o seguinte comando no terminal:

\begin{terminal}
> clang -S -emit-llvm nome.c -o nome.ll
\end{terminal}
Onde nome.c é o nome do arquivo c e nome.ll é o nome do arquivo de saída no código Assembly da LLVM.

Para que seja feita a execução na LLVM, os seguintes comandos devem ser seguidos:
\begin{terminal}
> llvm-as nome.ll
> lli nome.bc
\end{terminal}
Onde o primeiro comando cria o arquivo binário, e o segundo o executa na llvm.

Para criar o arquivo obj, utilizando o arquivo .bc do llvm, o seguinte comando é necessário:
\begin{terminal}
> llc -filetype=obj nome.bc
\end{terminal}

Após a criação do arquivo obj com o llc, o arquivo executável pode ser criado utilizando o GCC.
\begin{terminal}
> gcc nome.o
> ./a.out
\end{terminal}

Como nota de observação, temos que podemos gerar um arquivo executavel em C diretamente pelo GCC utilizando os comandos:
\begin{terminal}
> gcc nome.c -o nome.o
> ./nome
\end{terminal}
O primeiro comanda cria o arquivo .o (executavel) e o segundo faz sua execução.

\chapter{Programas de Teste}

A seguir, os programas em C, seguidos por sua tradução para Assembly da LLVM, no fim deste capítulo, é póssivel encontrar uma "tradução" para as intruções do assembly:

\section{Nano Programas}
%\lstinputlisting[label={arq:prog1.c}, language=C, caption={Módulo Mínimo C}]{codigos/MiniC/prog1.c}


\section{Micro Programas}


\section{Instruções Importantes}


\subsection{Tipos do LLVM}
Primitivos:\\
i1,i2,...,i8,....,i16,...,i32\\
label,void\\
float e double\\
\\
Derivados\\
Array: [40 x i32]\\
Pointers: [4 x i8]*\\
Structures: i32,(i32)*,i1\\
Function - <tiporetorno>(<parametro>):i32(i32)

\subsection{Condicionais}
Operadores possíveis condicionais de icmp\\
eq: Igual\\
ne: Diferente\\
ugt: unsigned Maior que\\
uge: unsigned Maior ou igual\\
ult: unsigned Menor que\\
ule: unsigned Menor ou igual\\
sgt: signed Maior que\\
sge: signed Maior ou igual\\
slt: signed Menor ou igual\\
sle: signed less or equal\\
\\
\\
Operadores possíveis condicionais de fcmp:\\
false: Sempre retorna falso, não importanto a operação.\\
true: Sempre retorna true, não importando a operação.\\
oeq: retorna true se todos os operadores não são QNAN e op1 é igual a op2.\\
ogt: retorna true se todos os operadores não são QNAN e op1 é maior que op2.\\
oge: retorna true se todos os operadores não são QNAN e op1 é maior ou igual que op2.\\
olt: retorna true se todos os operadores não são QNAN e op1 é menor que op2.\\
ole: retorna true se todos os operadores não são QNAN e op1 é menor ou igual que op2.\\
one: retorna true se todos os operadores não são QNAN e op1 é diferente de op2.\\
ord: retorna true se todos os operadores não são QNAN.\\
ueq: retrona true se qualquer operador é QNAN ou op1 é igual a op2.\\
ugt: retrona true se qualquer operador é QNAN ou op1 é maior que op2.\\
uge: retrona true se qualquer operador é QNAN ou op1 é maior ou igual que op2.\\
ult: retrona true se qualquer operador é QNAN ou op1 é menor que op2.\\
ule: retrona true se qualquer operador é QNAN ou op1 op1 é menor ou igual que op2.\\
une: retrona true se qualquer operador é QNAN ou op1 é diferente de op2.\\
uno: retrona true se qualquer operador é QNAN.\\

\section{Programas Extras}
Alguns programas extras para complementar a leitura.

%\lstinputlisting[label={arq:prog4.c}, language=C, caption={Atribuição de uma soma de inteiros a uma variável C}]{codigos/MiniC/prog4.c}


\chapter{Compilador}
O Compilador é um programa que traduz um programa de entrada de uma linguagem fonte para uma linguagem que possa ser indentida pela máquina. Esse processo demanda na quebra do programa em várias partes, para que seja entendido sua estrutura e significado. Para isso temos o front-end do compilador que é responsável por vários tipos de análises.

\textbf{Análise Léxica:}
Quebra a entrada (o código) em palavras conhecidas como tokens.

\textbf{Análise Sintática:}
Analisa a saída do analisador léxico estruturalmente.

\textbf{Análise Semântica:}
Cálcula o significado do programa.

Além desses passos o compilador ainda conta com geração de código intermediário, optimização de código e geraçãod de código final como fases do seu processo.

\section{Analisador Léxico}
O analisador léxico é responsável por separar uma sequencia de caracteres que representa o programa fonte em entidades ou tokens, estes que são símbolos básicos da linguagem. Durante a análise léxica, os tokens são classificados como palavras reservadas, identificadores, símbolos especiais, constantes de tipos básicos (int, float), entre outras. Ele lê o texto fonte, carácter por carácter identificando os elementos léxicos da linguagem (identificadores), ignorando comentários, brancos, e includes. Pode-se entende-lo  como uma forma de verificar determinado alfabeto e então, quando analisamos uma palavra, podemos definir através da análise léxica se existe ou não algum caracter que não faz parte do alfabeto da linguagem de programação.


Para compilar, devem ser seguidos os comandos:
\begin{terminal}
> ocamllex lexico.mll
> ocamlc -c lexico.ml
\end{terminal}


Para utiliza-lo, no terminal digite:
\begin{terminal}
> rlwrap ocaml
> #use "carregador.ml";;
\end{terminal}

Pode-se utilizar qualquer código deste documento em C para realizar os devidos testes do analisador, para isso com o ocaml aberto e o carregador carregado faça:
\begin{terminal}
> lex "nomedoarquivo.c";;
\end{terminal}

Um exemplo de saída de arquivo C correto pode ser visto abaixo (neste caso o programa utilizado foi o da Listagem 2.5 desde arquivo:

Lexico.tokens list =
[Lexico.INTEIRO; Lexico.MAIN; Lexico.APAR; Lexico.FPAR; Lexico.ACHAVE;
 Lexico.INTEIRO; Lexico.ID "n"; Lexico.PONTOEV; Lexico.ID "n"; Lexico.ATRIB;
 Lexico.LITINT 0; Lexico.PONTOEV; Lexico.FCHAVE; Lexico.EOF]

Segue abaixo alguns programas C que fazem o analisador ter como saída uma mensagem acusando determinado erro:

\chapter{Referências}
\href{http://llvm.org/releases/3.3/docs/LangRef.html}{LLVM Documentation}\\
\href{https://groups.google.com/forum/#!forum/comp_ufu}{Trabalhos de outros alunos do curso}\\
  
\end{document} 
